{"meta":{"title":"One Love, One Lifetime","subtitle":"相信技术的力量.learn once, write everywhere,write once, run anywhere","description":null,"author":"JingYuchun","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-10-20T09:25:58.000Z","updated":"2017-10-20T09:25:58.205Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2018Android面试笔记(一)","slug":"2018Android面试笔记(一)","date":"2018-05-14T16:00:00.000Z","updated":"2018-05-15T10:11:16.662Z","comments":true,"path":"2018/05/15/2018Android面试笔记(一)/","link":"","permalink":"http://yoursite.com/2018/05/15/2018Android面试笔记(一)/","excerpt":"","text":"2018Android面试笔记(一)2018年5月份了,当前公司由于项目完成了,也准备各奔东西了,因为是外包的,所以也开始了面试,下面记录下我遇到的面试公司以及每一面的过程. 一、广州博冠​ 这家是以硬件为主进行的智能软硬件结合的公司,硬件资源丰富,集团主要做望远镜等等很多,面试这家主要做智能家居方向的,目前有成熟的产品上线,接下来准备做智能监控方向的app项目,硬件工程师,后端工程师,硬件,软件都自己做,老牌公司,还是挺完整的. 第一面面试官看起来比较成熟,但也大不过我几岁,问的问题大概是基础内容,下面回忆整理下 网络方面 tcp/ip 三次握手过程 udp理解 多线程是否自己实现过/如何避免线程死锁等问题 基础方面 Android四大组件一一介绍 activity 生命周期以及每个周期的使用场景 service的起动方式以及区别和各自的使用场景 broadcast注册方式及为什么会有这两种方式各自存在的意义及使用场景是什么 contentprovider理解,能做什么. 项目方面 2D绘图原理(这个是个人项目里使用的 ) 自定义View过程(当场给一个需求,说出实现过程) 蓝牙通讯 解码包分包机制(传输数据过大)如何处理的 第二面第二次面试就比较简单了,面试官就是和你聊天,聊项目,聊之前的经历,因为我第一个项目耗费时间比较长,印象也比较深刻,就聊了很多,比如项目中遇到的最多最大的困难是什么,怎么解决的等 聊的还算愉快,就这样结束了,两次面试都没有提及薪酬待遇问题,这一点后来回去之后才发现. 二、广州拓普基因第一面这家公司是在珠江新城高德置地广场,离我现在的位置比较近,之前在官网了解了下,最终也没搞清楚是做怎么样的医疗项目,不管了,下面是面试过程…… 在前台稍等了下,进入小会议室,接连来了两个面试人员, 貌似技术人员的问题(为啥貌似,因为问题和技术好像也没什么关系) 自我介绍(我一贯的自我介绍都是从大学毕业到当前公司是怎么个过程说一遍 很简洁) 分别介绍下项目(依依介绍完毕) 项目人员分配/负责模块完成时间 为什么学软件 一个商城项目 一个人独立完成 大概需要多少时间 这个时候来了一个管理人员,下面的问题更是离谱 你觉得你的优势是什么 你觉得你的劣势是什么 如果有5个候选,凭什么会录入选你 你觉得有哪两点是在你入职后我会担心的 问道这 我已经不知道说什么了,后面就是谈个人规划,发展方向的了,他有他的见解,当然我也有自己的理解,他说完我说,都说完后就结束了,给我的感觉是很不舒服,面试过程一味无趣,没有和技术相关,貌似在做性格测试,我有个同事就经历过性格测试,好吧,这个就不说了,今天面试结束,静静等待结果,准备第二天面试.","categories":[],"tags":[]},{"title":"微信小程序零基础入门踩坑之路","slug":"微信小程序零基础入门踩坑之路","date":"2018-04-01T16:00:00.000Z","updated":"2018-04-02T08:30:28.440Z","comments":true,"path":"2018/04/02/微信小程序零基础入门踩坑之路/","link":"","permalink":"http://yoursite.com/2018/04/02/微信小程序零基础入门踩坑之路/","excerpt":"","text":"微信小程序.jpg ## 微信小程序 &gt; 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 &gt; 本人是一名忠实的Android研发,没有出过轨,对于css html js等仅仅是一知半解,这是在业余之际觉得想接触一下web,其实刚出来小程序那时候就尝试过,不过由于工作较忙,中途放弃了,如今小程序发展的还是挺快的,还是特别想学下前端知识.一是总结,二是分享给有需要的人,节省时间,少百度一些. 不说废话,直接说有用的,开始吧. ------ #### 申请帐号 1. 注册:[小程序注册](https://mp.weixin.qq.com/wxopen/waregister?action=step1)(不能是微信开放平台的邮箱) 2. 登录后, 我们可以在菜单 “设置”-“开发设置” 看到小程序的 **AppID** 。 ![appid.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f63de18eb75?w=1193&amp;h=458&amp;f=png&amp;s=36609) #### 安装开发工具 1. 前往 [开发者工具下载页面](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=2018327) ，根据自己的操作系统下载对应的安装包进行安装. 2. 打开小程序开发者工具，用微信扫码登录开发者工具 3. 选择**小程序**项目类型 ![项目类型.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f63de0192a0?w=396&amp;h=264&amp;f=png&amp;s=9385) 4. 填入你申请的APPID 会自动生成一个QuickStart Project 直接进入即可看到一个简单的小程序 ![QuickStart.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f63de178281?w=413&amp;h=725&amp;f=png&amp;s=26690) 5. 看看项目结构 挺清晰的. ![项目结构.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f63de37fe72?w=858&amp;h=584&amp;f=png&amp;s=77760) ​ 6. 至此,第一个小程序已经呈现在你面前,开发工具顶部栏有预览,你可以用手机扫描体验一下. ------ ​ #### 编辑器选择 &gt; 经过一顿百度和前端的朋友咨询,发现了目前网上流行的几款: 微信开发工具、VSCode、Subline、webstom......说多无益,我们就选朋友推荐的VSCode 其他的没用过,暂时不进行对比了. - 当然了 我们是进行微信小程序开发,而且是没有前端基础的,所以建议先在微信开发工具中进行开发 - 如果喜欢其他编辑器也可以[下载 VScode](https://code.visualstudio.com/) 里面有插件商店,提供各种插件,挺好的,主要是免费. #### UI组件库使用 这里说明下为什么要有使用这个,正所谓站在前人的肩膀上,能够看的更远,看到的东西更多,省去了你在造轮子了, 为了更快更好的开放一款自己的小程序,对于UI有强烈要求的就要用到别人写好的组件库了,不为什么,因为我不懂前端,让我自己写要学基础好几天,不过话说回来,基础还是要学的,这里只是想最快速度了解前端和小程序开发整体 - 原生组件库 微信本身提供的一套基础组件 官方教程有详细文档 - WeUI 同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计 - MinUI 第三方基于规范的小程序组件库，简洁、易用、工具化,并支持wepy和组件化方案等 - ZanUI 第三方的一个颜值高、好用、易扩展的微信小程序 UI 库 #### 立项 &gt; 如果你有其他语言的开发基础,那么可以直接进行开发,别怕,我们边做边学,我用了一个星期搞定,你也可以3天或者1天.下面拿我的练习项目为例 《[学安卓](https://github.com/jingyc0305/wxsmalldemo)》数据来源 鸿洋大神的网站API 《[玩安卓](http://www.wanandroid.com/)》用于搜集安卓技术文章及众多实用工具的,很方便,详细API可以查看[玩安卓的API文档](http://www.wanandroid.com/blog/show/2) 下面我们就开始第一个页面的开发 这是效果图 功能很简单,banner+列表 ##{% image https://user-gold-cdn.xitu.io/2018/4/2/16284f63e0a70d6f?w=399&h=710&f=png&s=111591 '1.png' '' %} #### 页面的生命周期 1234567891011121314151617181920212223242526272829303132333435363738Page(&#123;/*** 页面的初始数据*/data: &#123;&#125;,/*** 生命周期函数--监听页面加载*/onLoad: function (options) &#123;&#125;,/*** 生命周期函数--监听页面初次渲染完成*/onReady: function () &#123;&#125;,/*** 生命周期函数--监听页面显示*/onShow: function () &#123;&#125;,/*** 生命周期函数--监听页面隐藏*/onHide: function () &#123;&#125;,/*** 生命周期函数--监听页面卸载*/onUnload: function () &#123;&#125;,/*** 页面相关事件处理函数--监听用户下拉动作*/onPullDownRefresh: function () &#123;&#125;,/*** 页面上拉触底事件的处理函数*/onReachBottom: function () &#123;&#125;,/*** 用户点击右上角分享*/onShareAppMessage: function () &#123;&#125;&#125;) #### 首页 ##### 1.首页banner 1234http://www.wanandroid.com/banner/json方法：GET参数：无 可直接点击查看示例：&lt;http://www.wanandroid.com/banner/json&gt; ##### 2.首页文章列表 1234http://www.wanandroid.com/article/list/0/json方法：GET参数：页码，拼接在连接中，从0开始。 可直接点击查看示例：&lt;http://www.wanandroid.com/article/list/1/json&gt;。 注意：页码从0开始，拼接在链接上。 其中有两个易混淆的字段: 12&quot;superChapterId&quot;: 153,&quot;superChapterName&quot;: &quot;framework&quot;, // 一级分类的名称 superChapterId其实不是一级分类id，因为要拼接跳转url，内容实际都挂在二级分类下，所以该id实际上是一级分类的第一个子类目的id，拼接后故可正常跳转。 ------ **附上index.wxml参考代码:** ![index.wxml](https://user-gold-cdn.xitu.io/2018/4/2/16285711b0d72f81?w=1436&amp;h=760&amp;f=png&amp;s=156983) **附上index.js参考代码:** - data里是数据绑定的关键,即布局中定义的变量和这里都是对应的,当这里的值被赋值或变更,影响页面更新. - 使用方法 变量名:默认值 如:imgUrls: [] - `imgUrls:[] 为banner的数组来源,在布局wxml中可以找到 在wxml中一定是{{}}双层大括号才可以.` - ​ block为块 具体查看文档介绍 - ​ wx:for为循环列表对应的数据源 在小程序中即为数组对象 - ​ wx:key 为每个item的唯一标识 - `item变量代指为循环列表默认的其中的元素对象 也可以指定名称 如:wx:for-item=&quot;{{banner_item}}&quot;` ![wxml.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f640d5353f6?w=1079&amp;h=253&amp;f=png&amp;s=28059) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//获取应用实例var app = getApp()Page(&#123;data: &#123;imgUrls: [],mode: &apos;aspectFill&apos;,indicatorDots: true,autoplay: true,interval: 3000,duration: 1000,articals: [],curPage: 1,perPageSize: 20,pageCount: 59,isHideLoadMore: false,loadingMoreHidden: true,dir:&apos;top&apos;,item_content_dir:&apos;between&apos;,likesrc:&apos;../images/index/like_normal.png&apos;&#125;,//进入文章详细页面goToArticalDetail: function (e) &#123;var that = thisvar item_index = parseInt(e.currentTarget.dataset.index)console.log(&quot;item_index = &quot; + item_index)wx.navigateTo(&#123;url: &apos;../index-detail/index-detail?title=&apos; + that.data.articals[item_index].title + &apos;&amp;link=&apos; + that.data.articals[item_index].link&#125;)&#125;,onLoad: function () &#123;console.log(&apos;onLoad&apos;)//显示标题菊花wx.showNavigationBarLoading()//获取轮播图this.getBanners()//默认加载第0页var curPage = 0//获取文章列表this.getArticals(curPage)&#125;,onPullDownRefresh: function () &#123;this.data.curPage = 0this.getArticals(0)console.log(&apos;下拉刷新&apos;)&#125;,onReachBottom: function () &#123;console.log(&apos;加载更多&apos;)if (!this.data.loadingMoreHidden) &#123;&#125; else &#123;this.getArticals(this.data.curPage)&#125;this.setData(&#123;loadingMoreHidden: true&#125;)&#125;,showAddItem: function () &#123;this.setData(&#123;addVlue: !this.data.addVlue&#125;)&#125;,getArticals: function (artical_pageindex) &#123;var that = thiswx.request(&#123;url: &apos;http://www.wanandroid.com/article/list/&apos; + artical_pageindex + &apos;/json&apos;,data: &#123;&#125;,method: &apos;GET&apos;,header: &#123;&apos;content-type&apos;: &apos;application/json&apos;&#125;,success: function (res) &#123;wx.hideNavigationBarLoading()that.setData(&#123;perPageSize: res.data.data.size,curPage: res.data.data.curPage,pageCount: res.data.data.pageCount&#125;)var articalsTemp = that.data.articalsif (that.data.curPage == 1) &#123;articalsTemp = []&#125;var articals = res.data.data.datasif (articals.length &lt; that.data.perPageSize) &#123;console.log(&apos;没有更多了&apos;)that.setData(&#123;articals: articalsTemp.concat(articals),loadingMoreHidden: false&#125;)&#125; else &#123;console.log(&apos;有更多可加载&apos;)that.setData(&#123;articals: articalsTemp.concat(articals),loadingMoreHidden: true,curPage: that.data.curPage + 1&#125;)&#125;&#125;&#125;)&#125;,getBanners: function () &#123;var that = thiswx.request(&#123;url: &apos;http://www.wanandroid.com/banner/json&apos;,data: &#123;&#125;,method: &apos;GET&apos;,header: &#123;&apos;content-type&apos;: &apos;application/json&apos;&#125;,success: function (res) &#123;wx.stopPullDownRefresh()that.setData(&#123;imgUrls: res.data.data&#125;)&#125;&#125;)&#125;,//添加文章到我的收藏onClickAddLike: function()&#123;&#125;&#125;) **index.wcss参考GitHub源代码:** **附上index.json参考代码:** 说明: 我项目中的UI组件库引用了MinUI和WeUI,具体使用参照 [MinUI组件库仓库地址]: https://github.com/meili/minui [Min-Cli使用手册地址]: https://meili.github.io/min/docs/install/index.html 123456789&#123;&quot;navigationBarTitleText&quot;: &quot;玩安卓&quot;,&quot;usingComponents&quot;: &#123;&quot;wxc-toast&quot;: &quot;../../dist/packages/@minui/wxc-toast/dist/index&quot;,&quot;wxc-icon&quot;: &quot;../../dist/packages/@minui/wxc-icon/dist/index&quot;,&quot;wxc-label&quot;: &quot;../../dist/packages/@minui/wxc-label/dist/index&quot;,&quot;wxc-flex&quot;: &quot;../../dist/packages/@minui/wxc-flex/dist/index&quot;&#125;&#125; [WeUI组件库仓库地址]: https://github.com/Tencent/weui ![引入WeUI组件样式](https://user-gold-cdn.xitu.io/2018/4/2/16284f6413ae3197?w=377&amp;h=254&amp;f=png&amp;s=5700) ![1522639536966.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f640171716c?w=762&amp;h=376&amp;f=png&amp;s=45211) 将下载的weui.wxss文件放至项目的根目录下 在app.wxss文件中 @import &apos;weui.wxss&apos;即可使用了. ------ #### 底部tabBar 在app.json中配置即可 1234567891011121314151617181920212223242526272829303132333435&quot;tabBar&quot;: &#123;&quot;selectedColor&quot;: &quot;#69C3AA&quot;,&quot;list&quot;: [&#123;&quot;pagePath&quot;: &quot;pages/index/index&quot;,&quot;text&quot;: &quot;首页&quot;,&quot;iconPath&quot;: &quot;pages/images/nav/home_normal.png&quot;,&quot;selectedIconPath&quot;: &quot;pages/images/nav/home_select.png&quot;&#125;,&#123;&quot;pagePath&quot;: &quot;pages/nav/nav&quot;,&quot;text&quot;: &quot;导航&quot;,&quot;iconPath&quot;: &quot;pages/images/nav/nav_normal.png&quot;,&quot;selectedIconPath&quot;: &quot;pages/images/nav/nav_select.png&quot;&#125;,&#123;&quot;pagePath&quot;: &quot;pages/project/project&quot;,&quot;text&quot;: &quot;项目&quot;,&quot;iconPath&quot;: &quot;pages/images/nav/project_normal.png&quot;,&quot;selectedIconPath&quot;: &quot;pages/images/nav/project_select.png&quot;&#125;,&#123;&quot;pagePath&quot;: &quot;pages/hierarchy/hierarchy&quot;,&quot;text&quot;: &quot;体系&quot;,&quot;iconPath&quot;: &quot;pages/images/nav/tool_normal.png&quot;,&quot;selectedIconPath&quot;: &quot;pages/images/nav/tool_select.png&quot;&#125;,&#123;&quot;pagePath&quot;: &quot;pages/mine/mine&quot;,&quot;text&quot;: &quot;我&quot;,&quot;iconPath&quot;: &quot;pages/images/nav/mine_normal.png&quot;,&quot;selectedIconPath&quot;: &quot;pages/images/nav/mine_select.png&quot;&#125;]&#125; #### 网络请求 示例代码 说明: - url:为请求接口 - data:请求参数 - method: 请求方式 - header:请求头 - success:function(res){}请求回调函数 一般在这里进行数据绑定赋值 达到页面更新 - that.setData{()} 赋值data中的变量 123456789101112131415wx.request(&#123;url: &apos;http://www.wanandroid.com/banner/json&apos;,data: &#123;&#125;,method: &apos;GET&apos;,header: &#123;&apos;content-type&apos;: &apos;application/json&apos;&#125;,success: function (res) &#123;wx.stopPullDownRefresh()that.setData(&#123;imgUrls: res.data.data&#125;)&#125;&#125;) #### 页面跳转及参数传递 示例代码 说明: `item_index:e.currentTarget.dataset.index 获取item下标索引 对应wxml中 data-index=&quot;{{index}}&quot;` wx.navigateTo({})页面跳转 url:&apos;path?xxx=xxx&amp;xxx=xxx....&apos; 页面路径+参数拼接 options.xxx 参数接收 在onload中 123456789//进入文章详细页面goToArticalDetail: function (e) &#123;var that = thisvar item_index = parseInt(e.currentTarget.dataset.index)console.log(&quot;item_index = &quot; + item_index)wx.navigateTo(&#123;url: &apos;../index-detail/index-detail?title=&apos; + that.data.articals[item_index].title + &apos;&amp;link=&apos; + that.data.articals[item_index].link&#125;)&#125;, 12345678910111213141516/*** 生命周期函数--监听页面加载*/onLoad: function (options) &#123;var that = thisvar title = options.titlevar link = options.linkthat.setData(&#123;artical_title: title,artical_link : link&#125;)//动态设置页面标题---文章标题wx.setNavigationBarTitle(&#123;title: that.data.artical_title&#125;)&#125;, #### 下拉刷新/上拉加载更多 1.在app.json中加入开关 只有打开开关 生命周期函数才会被调用 &gt; 在这里说明一个容易犯错的就是创建page的时候会自动生成四个文件,js文件中也会自动生成模板代码 生命周期函数都会自动生成,千万不要自己去在写一个 否则不报错 也不触发. 1234567891011&quot;window&quot;: &#123;&quot;backgroundTextStyle&quot;: &quot;light&quot;,&quot;navigationBarBackgroundColor&quot;: &quot;#69C3AA&quot;,&quot;navigationBarTitleText&quot;: &quot;玩安卓&quot;,&quot;navigationBarTextStyle&quot;: &quot;white&quot;,&lt;!--打开下拉刷新--&gt;&quot;enablePullDownRefresh&quot;: true,&lt;!--打开上拉加载更多--&gt;&quot;onReachBottomDistance&quot;: true,&quot;backgroundColor&quot;: &quot;#69C3AA&quot;&#125;, 12345onPullDownRefresh: function () &#123;this.data.curPage = 0this.getArticals(0)console.log(&apos;下拉刷新&apos;)&#125;, 1234567891011onReachBottom: function () &#123;console.log(&apos;上拉加载更多&apos;)if (!this.data.loadingMoreHidden) &#123;&#125; else &#123;this.getArticals(this.data.curPage)&#125;this.setData(&#123;loadingMoreHidden: true&#125;)&#125;, 2.主要的上拉加载逻辑控制在getArticals()f方法里处理的 我们慢慢分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 getArticals: function (artical_pageindex) &#123; var that = this &lt;!--请求文章列表数据--&gt; wx.request(&#123; url: &apos;http://www.wanandroid.com/article/list/&apos; + artical_pageindex + &apos;/json&apos;, data: &#123; &#125;, method: &apos;GET&apos;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res) &#123; wx.hideNavigationBarLoading() that.setData(&#123; perPageSize: res.data.data.size, curPage: res.data.data.curPage, pageCount: res.data.data.pageCount &#125;) &lt;!--上拉加载更多的关键处理--&gt; &lt;!--定义一个新的文章对象数组 用于装载拼接所有页的数据--&gt; var articalsTemp = that.data.articals &lt;!--当前如果处于第一页 那么清空这个对象数组 只装载第一页数据即可--&gt; if (that.data.curPage == 1) &#123; articalsTemp = [] &#125; &lt;!--定义一个新的文章对象数组 赋值于请求返回对应页码的文章数据--&gt; var articals = res.data.data.datas &lt;!--判断,如果返回的某页的数据长度小于每页的数据长度 说明当前加载的页是最后一页了--&gt; if (articals.length &lt; that.data.perPageSize) &#123; console.log(&apos;没有更多了&apos;) that.setData(&#123; &lt;!--contcat 意思是向articalsTemp数组中添加数组 --&gt; articals: articalsTemp.concat(articals), loadingMoreHidden: false &#125;) &#125; else &#123;&lt;!-否则 当前不是最后一页,向articalsTemp数组中添加数组 --&gt; console.log(&apos;有更多可加载&apos;) that.setData(&#123; articals: articalsTemp.concat(articals), loadingMoreHidden: true, &lt;!--当前页码增加1 依次类推--&gt; curPage: that.data.curPage + 1 &#125;) &#125; &#125; &#125;) &#125;, #### 自定义组件 - 创建自定义组件 与创建普通页面类似 也包含.js .json .wxml .wxcss四个文件 - 修改.json文件组件属性 1234&#123;&quot;component&quot;: true,&quot;usingComponents&quot;: &#123;&#125;&#125; - 编写wantab.js 附上wantab.js源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dist/wantab.jsComponent(&#123;/*** 组件的属性列表*/properties: &#123;//标题列表tablist: &#123;type: Array,value: []&#125;,currentTab: &#123;type: Number,value: 0,observer: function (newVale, oldVal) &#123;this.setData(&#123;currentTab: newVale&#125;)&#125;&#125;,tabname: &#123;type: String,value: &apos;&apos;&#125;,tabtype: &#123;type: Number,value: &apos;&apos;&#125;&#125;,/*** 组件的初始数据*/data: &#123;&#125;,/*** 组件的方法列表*/methods: &#123;onClickNavBar: function (e) &#123;this.triggerEvent(&apos;changeTab&apos;, &#123;currentNum: e.currentTarget.dataset.current&#125;)&#125;&#125;&#125;) - 编写wantab.wxml 附上wantab.wxml 模板代码 - 编写wantab.js 附上wantab.wxcss 组件样式 123456789101112131415161718/* dist/wantab.wxss */.scroll-view-x&#123;background-color: #fff;white-space: nowrap;position:fixed;z-index:10;top:0&#125;.scroll-view-x .scroll-view-item&#123;display:inline-block;margin:0 35rpx;line-height: 33px;cursor: pointer;&#125;.on&#123;border-bottom: 2px solid #69C3AA;color: #69C3AA&#125; 以上就可以完成一个组件的定义了,下面贴出使用方法 123456&#123;&quot;navigationBarTitleText&quot;: &quot;项目&quot;,&quot;usingComponents&quot;: &#123;&quot;wantab&quot;:&quot;../../dist/component/wantab/wantab&quot;&#125;&#125; &gt; 使用方式与其他第三方的组件引入一致,在页面的.json文件中加入以上代码即可 注意路径根据项目而改变 ------ #### 效果图展示 最后放上其他页面的效果图 实现过程基本差不多 刚接触web 所以多做了些重复的工作,为了更熟悉使用这些组件和交互 ![1.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f63e0a70d6f?w=399&amp;h=710&amp;f=png&amp;s=111591) ![2.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f641399c328?w=403&amp;h=715&amp;f=png&amp;s=63516) ![3.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f6425bed96e?w=402&amp;h=713&amp;f=png&amp;s=153668) ![4.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f642a6c5f3e?w=403&amp;h=714&amp;f=png&amp;s=87098) ![5.png](https://user-gold-cdn.xitu.io/2018/4/2/16284f642cd7be16?w=401&amp;h=712&amp;f=png&amp;s=100637) ------ #### 完结 感谢阅读,如有不对地方请见谅.","categories":[],"tags":[]},{"title":"学习使用Gitlab Pull/Push/Request","slug":"学习使用GitLab Pull Push Request","date":"2017-12-05T16:00:00.000Z","updated":"2018-04-02T06:25:19.284Z","comments":true,"path":"2017/12/06/学习使用GitLab Pull Push Request/","link":"","permalink":"http://yoursite.com/2017/12/06/学习使用GitLab Pull Push Request/","excerpt":"","text":"GitLab 简介 官网 特征 1.GitLjavascript:void(null)ab 被任命为Forrester Wave 的领导者 2.GitLab 提供易用性,可扩展性,集成性和创新性 3.使用方式与码云略有不同,代码访问权限控制的更细致 4.提供web和客户端方式且免费创建私有库 如何使用 第一步 fork 源代码至自己的仓库 fork 源代码 自己的仓库.png 第二步 clone 源代码 ​ 方式一 Android Studio 操作 clone 源代码.png ​ 方式二 Git Bash 命令: git clone project_url 在自己选择的磁盘下再启动Git Bash 将项目拷贝到指定目录下 1git clone xxxxxxx.git 第三步 pull 源代码 ​ 方式一 Android Studio 操作 pull 源代码.png ​ 方式二 本地文件夹右键 文件夹右键.png ​ 方式三 Git Bash 命令: 123$ git fetch origin master //相当于是从远程获取最新版本到本地，不会自动合并。$ git log -p master..origin/master$ git merge origin/master ​ 或者 1git pull origin master //相当于是从远程获取最新版本并merge到本地 第四步 切换分支 12$ git branch -a //列出所有分支$ git checkout origin/master //检出指定分支 第五步 代码开发及修改 ​ 此处省略……………. 第六步 代码提交commit ​ 方式一 Android Studio操作 提交commit.png ​ 方式二 文件夹右键操作 ​ 方式三 Git Bash命令: 1234$ git status //查看代码状态变化$ git add -A //提交所有修改内容$ git commit -m &quot;xxxx&quot; //提交至本地 xxx为提交说明文字$ git push //推送到自己的远程仓库 一般直接 commit and push 也可分开两个步骤 第七步 push代码到自己的仓库 ​ 方式一 Android Studio操作 略……. ​ 方式二 文件夹右键操作 略……. ​ 方式三 Git Bash命令: 1$ git push //推送到自己的远程仓库 以上 第六步和第七部 commit 和 push 可以一气呵成. 第八步 更新源代码 ​ 防止此操作前有人更新代码 直接合并会产生冲突 或者 覆盖别人的代码等问题 这里最好更新一次 ​ 重复第三步 最后一步啦 第九步 merge request 合并代码请求 合并代码.png 等待代码被合并…… 第十步 等待修bug……然后重复以上操作…… 完结 持续更新 此篇文章只是工作中要做的基本操作 写出来是为了分享给别人参考 如果有错 希望指正 刚刚接触git使用 不是很熟练 大部分都是不断摸索的 最开始SVN 后来码云 GitHub 如今GitLab 也差不多 熟能生巧. 同时也是练习MarkDown 也是刚接触.谢谢阅读.推荐Typora 挺好用的 免费额.","categories":[],"tags":[]},{"title":"Android高效绘图-平移缩放卡顿","slug":"Android高效绘图-平移缩放卡顿","date":"2017-10-19T16:00:00.000Z","updated":"2017-10-20T10:36:58.559Z","comments":true,"path":"2017/10/20/Android高效绘图-平移缩放卡顿/","link":"","permalink":"http://yoursite.com/2017/10/20/Android高效绘图-平移缩放卡顿/","excerpt":"","text":"本人新手一枚,第一次写博客,写的不好请勿喷,困扰小弟很久的问题,今天终于解决,这里奉上,供小伙伴借鉴,后面我会奉上从基础手指绘图到平移缩放所有的实现过程以及走过的坑,言归正传,下面开始列出我寻找卡顿元凶之路. 采用双重画布的方式进行缓存—-无明显效果 修改绘图框架,减少绘图中的大量计算,优化了数据结构—并无作用 对象池的使用,避免重绘方法OnDraw中创建大量的对象(Path)—貌似没什么改变 各种分析过后知道了应该是内存抖动,垃圾回收机制造成的卡顿,开始尝试对象的软引用—然而也无作用 崩溃了的同时,放弃一段时间,但不管是坐车还是吃饭还是睡觉前,都会在想是什么鬼东西呢,边想着边做着其他功能,但是越做越觉得这个卡顿问题一天不解决,一天心情就不好了 最终在百谷了很久无果后,开始觉得对APP内存的使用检测,开始学习,应该会找到答案 功夫不负有心人,解决了~ 不卖关子了,开始奉上解决方式,其实很简单,我只是新手,觉得很low的请左上角返回,不要喷我. 使用工具Eclipse DDMS Heap分析 Allocation Tracker 分析 onDraw()代码块所有绘制的对象，例如：画直线,弧线,矩形,填充,等等.需要绘制的不可预知多少的的对象,所以这里不可避免需要重绘,循环遍历对象的绘制方法,这里也是出现问题的根源,重绘的时候会调用每个对象的绘图方法,方法中一定会创建一些对象,比如:new Path();当然卡顿他不是最终凶手,不过后面还需要对他进行使用对象池,避免创建过多的path对象. 12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas)&#123; super.onDraw(canvas); mCanvas = canvas; try &#123; lFHouse.setBacgroundColor(this, paint_region_bag); for(LFWall wall : lFHouse.houseWalls)&#123; wall.doDraw(this, mCanvas) &#125; for(LFWall wall : lFHouse.houseWalls)&#123; for (LFDoor door : wall.walldoors) &#123; door.onDraw(this, mCanvas); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; ###第一步 运行程序,切换到DDMS视图 如题所示操作 这里写图片描述 ###第二步 操作程序有卡顿的地方几次,手动点击Cause GC 如图 这里写图片描述 ###第三步 分析一下,多次操作,多次Cause GC,注意看free中的Total Size 大小,如果抖动的比较大,但是每次都能降低,反复增大,减少,说明存在了内存的抖动,即当前操作存在短时间内创建大量的对象,占用的内存,唤起了GC短时间内快速去回收无用的对象,这个回收的时间内,程序的其他操作是需要等待GC完成才可以继续工作的,所有就出现了卡慢,对象太多,gc的遍历回收工作占用的时间就过长了.可以通过data object的数量可以清楚的看到内存的剧增和剧减的情况. 通过以上分析,我们知道了程序卡顿的具体原因,下面就需要找出是哪些对象占用了呢,找出他必须弄死他. ###第四步 打开Allocation Tracker视图,这个家伙很重要,能追踪查看内存到底让哪个小崽子占用了,还可以定位到包名,类名,代码行数,厉害了,我才会使用..,忏愧啊.勿喷小伙伴门.如图所示: 这里写图片描述 第五步 这里写图片描述 这里写图片描述 这里说明一下 ,由于我优化了程序,查找元凶的现场,已被我清理,所以这里看不到那些真正的元凶.下面我列出元凶,以供小伙伴借鉴. [TOC] 揭露卡顿元凶元凶1:12345678910//这个方法是用来做精度转换的 保留几位小数public static float round(float v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); &#125; //重点是下面这段代码 BigDecimal b = new BigDecimal(Float.toString(v)); BigDecimal one = new BigDecimal(&quot;1&quot;); return b.divide(one, scale, BigDecimal.ROUND_HALF_UP).floatValue(); &#125; 1.BigDecimal 对象占用的资源BigInteger通过追踪内存占用显示,这里就不贴图了. 这里解释下为什么会,由于我这个方法,在画线的时候对于每个点的x,y都进行了精度转换处理,又因为在平移缩放的时候我们是需要不断重绘的,也就是不断执行onDraw()这个系统方法,那么在这里我循环调用重绘线条,每一个点的x,y都需要重新计算并转换,造成了不断new BigDecimal(). 这个内部机制我还需要去底层源码去看下,现在只知道是这个东西占用了不少的内存,每new 一个好像是占用了144 2. Float.toString(v)这个转换也是占用了很大资源StringBuilder 具体底层小弟也是不能深入解释了 3. .floatValue() 这个也是占用了很多 char[] 数组. 元凶2:12345678910111213141516171819/* * 屏幕的宽 */ public static int getScreenWidth(Activity activity)&#123; DisplayMetrics dm = new DisplayMetrics(); dm = activity.getResources().getDisplayMetrics(); activity.getWindowManager().getDefaultDisplay().getMetrics(dm); return dm.widthPixels ; &#125; /* * 屏幕的高 */ public static float getScreenHeigth(Activity activity)&#123; DisplayMetrics dm = new DisplayMetrics(); dm = activity.getResources().getDisplayMetrics(); activity.getWindowManager().getDefaultDisplay().getMetrics(dm); return dm.heightPixels ; &#125; 这里贴出的获取屏幕的宽高代码是 很正常的方法,看起来没什么特别.在看下面:123456789//该方法是我用于真实坐标点与屏幕坐标点的一个转换 public LFPoint GetScreenPoint(LFPoint Point) &#123; float X = (float) (Zoom * DotsPerMeter * Point.x + Origin.x); float Y = (float) (DisplayUtil.getScreenHeigth(drawActivity) - Zoom * DotsPerMeter * Point.y + Origin.y); //X = DataUtils.round(X, 2); //Y = DataUtils.round(Y, 2); LFPoint p = new LFPoint(X, Y, Point.bulge); return p; &#125; 重点就是 重绘的时候每个点都要不断的进行转换,也就是在onDraw中不断的随手指的移动和缩放进行转换...看到了吗 下面有调用到获取屏幕的静态方法.就是它,不断的在获取,获取......导致了占用大量的资源 貌似也是每个144.我们继续...找 到这里,我们的程序的卡顿情况,被我们清理的差不多了,终于不会卡了,瞬间感觉整个人都飘了,原来自己给自己挖了那么多的坑,小弟真实惭愧,网上的代码段固然方便,但是不能一味的直接拿来用,其中很多不知道的东西,你往往忽略了的地方就是问题存在的地方,当你无计可施的时候,还需要坚持 一步步探索,找寻答案.顺便再啰嗦一句,onDraw中不可避免的是创建大量的path对象,这里根据网上搜寻的结果,总结了下还是用对象池比较好,但是网上有两个版本,一个是可以任何对象的,一个是只有自定义的类对象才可以,系统Path对象好像不行,所以简单的做了一下改动,对,就是自定义path, 我啥都没改 仅仅是extend了一下,然后套用了下面的对象池的初始化方法,类似Handler的获取Message的时候的方式一样,不知道对不对,贴出代码,参考一下,反正我试过,可用. 12345678910111213public class MyPath extends Path &#123; private static final SynchronizedPool&lt;MyPath&gt; sPool = new SynchronizedPool&lt;MyPath&gt;(10); public static MyPath obtain() &#123; MyPath instance = sPool.acquire(); return (instance != null) ? instance : new MyPath(); &#125; public void recycle() &#123; sPool.release(this); &#125;&#125; 好了,以上的寻找卡顿元凶之路,终于告一段落,还有很多地方需要优化的,后面再继续奉上,感谢看完的小伙伴,忍不住发一篇,希望能帮到你,后面我会继续更新出绘图相关的操作,比如画布的,比如view的,还有缩放,平移的实现,这些你是百谷不到的,那些基础的东西我看过很多,真的是千篇一律的.针对的平移缩放都是图片的操作而不是坐标点.下次再见~有高见欢迎点评,虚心接受.","categories":[],"tags":[]},{"title":"使用GitHub+Hexo搭建个人博客","slug":"学习搭建个人博客","date":"2017-10-19T16:00:00.000Z","updated":"2017-10-20T10:38:21.830Z","comments":true,"path":"2017/10/20/学习搭建个人博客/","link":"","permalink":"http://yoursite.com/2017/10/20/学习搭建个人博客/","excerpt":"","text":"第一个MarkDown文章","categories":[],"tags":[]}]}