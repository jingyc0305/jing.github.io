<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>One Love, One Lifetime</title>
  
  <subtitle>相信技术的力量.learn once, write everywhere,write once, run anywhere</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-20T10:36:58.559Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JingYuchun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android高效绘图-平移缩放卡顿</title>
    <link href="http://yoursite.com/2017/10/20/Android%E9%AB%98%E6%95%88%E7%BB%98%E5%9B%BE-%E5%B9%B3%E7%A7%BB%E7%BC%A9%E6%94%BE%E5%8D%A1%E9%A1%BF/"/>
    <id>http://yoursite.com/2017/10/20/Android高效绘图-平移缩放卡顿/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-10-20T10:36:58.559Z</updated>
    
    <content type="html"><![CDATA[<p>本人新手一枚,第一次写博客,写的不好请勿喷,困扰小弟很久的问题,今天终于解决,这里奉上,供小伙伴借鉴,后面我会奉上从基础手指绘图到平移缩放所有的实现过程以及走过的坑,言归正传,下面开始列出我寻找卡顿元凶之路.</p><ul><li><p><strong>采用双重画布的方式进行缓存—-无明显效果</strong></p></li><li><p><strong>修改绘图框架,减少绘图中的大量计算,优化了数据结构—并无作用</strong></p></li><li><p><strong>对象池的使用,避免重绘方法OnDraw中创建大量的对象(Path)—貌似没什么改变</strong></p></li><li><p><strong>各种分析过后知道了应该是内存抖动,垃圾回收机制造成的卡顿,开始尝试对象的软引用—然而也无作用</strong></p></li><li><p><strong>崩溃了的同时,放弃一段时间,但不管是坐车还是吃饭还是睡觉前,都会在想是什么鬼东西呢,边想着边做着其他功能,但是越做越觉得这个卡顿问题一天不解决,一天心情就不好了</strong></p></li><li><p><strong>最终在百谷了很久无果后,开始觉得对APP内存的使用检测,开始学习,应该会找到答案</strong></p></li><li><p><strong>功夫不负有心人,解决了~</strong></p></li><li><p><strong>不卖关子了,开始奉上解决方式,其实很简单,我只是新手,觉得很low的请左上角返回,不要喷我.</strong></p></li></ul><hr><h2 id="使用工具Eclipse-DDMS"><a href="#使用工具Eclipse-DDMS" class="headerlink" title="使用工具Eclipse DDMS"></a>使用工具Eclipse DDMS</h2><hr><ul><li><p>Heap分析</p></li><li><p>Allocation Tracker 分析</p></li></ul><hr><h3 id="onDraw-代码块"><a href="#onDraw-代码块" class="headerlink" title="onDraw()代码块"></a>onDraw()代码块</h3><pre><code>所有绘制的对象，例如：画直线,弧线,矩形,填充,等等.需要绘制的不可预知多少的的对象,所以这里不可避免需要重绘,循环遍历对象的绘制方法,这里也是出现问题的根源,重绘的时候会调用每个对象的绘图方法,方法中一定会创建一些对象,比如:new Path();当然卡顿他不是最终凶手,不过后面还需要对他进行使用对象池,避免创建过多的path对象.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas)&#123;</div><div class="line">super.onDraw(canvas);</div><div class="line">mCanvas = canvas;</div><div class="line">try &#123;</div><div class="line">lFHouse.setBacgroundColor(this, paint_region_bag);</div><div class="line"></div><div class="line">for(LFWall wall : lFHouse.houseWalls)&#123;</div><div class="line">              wall.doDraw(this, mCanvas)</div><div class="line">&#125;</div><div class="line">for(LFWall wall : lFHouse.houseWalls)&#123;</div><div class="line">for (LFDoor door : wall.walldoors) &#123;</div><div class="line">door.onDraw(this, mCanvas);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###第一步</p><pre><code>运行程序,切换到DDMS视图 如题所示操作</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170303114323104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQ4Njg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><hr><p>###第二步<br>     操作程序有卡顿的地方几次,手动点击Cause GC 如图<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170303114613576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQ4Njg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><hr><p>###第三步<br>    分析一下,多次操作,多次Cause GC,注意看free中的Total Size 大小,如果抖动的比较大,但是每次都能降低,反复增大,减少,说明存在了内存的抖动,即当前操作存在短时间内创建大量的对象,占用的内存,唤起了GC短时间内快速去回收无用的对象,这个回收的时间内,程序的其他操作是需要等待GC完成才可以继续工作的,所有就出现了卡慢,对象太多,gc的遍历回收工作占用的时间就过长了.可以通过data object的数量可以清楚的看到内存的剧增和剧减的情况.<br>    通过以上分析,我们知道了程序卡顿的具体原因,下面就需要找出是哪些对象占用了呢,找出他必须弄死他.</p><hr><p>###第四步</p><p>打开Allocation Tracker视图,这个家伙很重要,能追踪查看内存到底让哪个小崽子占用了,还可以定位到包名,类名,代码行数,厉害了,我才会使用..,忏愧啊.勿喷小伙伴门.如图所示:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170303123728227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQ4Njg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><hr><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170303123808072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQ4Njg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20170303124910773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjQ4Njg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><pre><code>这里说明一下 ,由于我优化了程序,查找元凶的现场,已被我清理,所以这里看不到那些真正的元凶.下面我列出元凶,以供小伙伴借鉴.</code></pre><p>[TOC]</p><h3 id="揭露卡顿元凶"><a href="#揭露卡顿元凶" class="headerlink" title="揭露卡顿元凶"></a>揭露卡顿元凶</h3><h4 id="元凶1"><a href="#元凶1" class="headerlink" title="元凶1:"></a>元凶1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//这个方法是用来做精度转换的 保留几位小数</div><div class="line">public static float round(float v, int scale) &#123;</div><div class="line">if (scale &lt; 0) &#123;</div><div class="line">throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);</div><div class="line">&#125;</div><div class="line">//重点是下面这段代码</div><div class="line">BigDecimal b = new BigDecimal(Float.toString(v));</div><div class="line">BigDecimal one = new BigDecimal(&quot;1&quot;);</div><div class="line">return b.divide(one, scale, BigDecimal.ROUND_HALF_UP).floatValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><pre><code>  1.BigDecimal 对象占用的资源BigInteger通过追踪内存占用显示,这里就不贴图了.这里解释下为什么会,由于我这个方法,在画线的时候对于每个点的x,y都进行了精度转换处理,又因为在平移缩放的时候我们是需要不断重绘的,也就是不断执行onDraw()这个系统方法,那么在这里我循环调用重绘线条,每一个点的x,y都需要重新计算并转换,造成了不断new BigDecimal(). 这个内部机制我还需要去底层源码去看下,现在只知道是这个东西占用了不少的内存,每new 一个好像是占用了144  2. Float.toString(v)这个转换也是占用了很大资源StringBuilder 具体底层小弟也是不能深入解释了  3. .floatValue() 这个也是占用了很多 char[] 数组.</code></pre><h4 id="元凶2"><a href="#元凶2" class="headerlink" title="元凶2:"></a>元凶2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 屏幕的宽</div><div class="line"> */</div><div class="line">public static int getScreenWidth(Activity activity)&#123;</div><div class="line">    DisplayMetrics dm = new DisplayMetrics();</div><div class="line">dm = activity.getResources().getDisplayMetrics();</div><div class="line">activity.getWindowManager().getDefaultDisplay().getMetrics(dm);</div><div class="line">   return dm.widthPixels ;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 屏幕的高</div><div class="line"> */</div><div class="line">   public static float getScreenHeigth(Activity activity)&#123;</div><div class="line">    DisplayMetrics dm = new DisplayMetrics();</div><div class="line">dm = activity.getResources().getDisplayMetrics();</div><div class="line">activity.getWindowManager().getDefaultDisplay().getMetrics(dm);</div><div class="line">   return dm.heightPixels ;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>这里贴出的获取屏幕的宽高代码是 很正常的方法,看起来没什么特别.在看下面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//该方法是我用于真实坐标点与屏幕坐标点的一个转换 </div><div class="line">public LFPoint GetScreenPoint(LFPoint Point) &#123;</div><div class="line">float X = (float) (Zoom * DotsPerMeter * Point.x + Origin.x);</div><div class="line">float Y = (float) (DisplayUtil.getScreenHeigth(drawActivity) - Zoom * DotsPerMeter * Point.y + Origin.y);</div><div class="line">//X = DataUtils.round(X, 2);</div><div class="line">//Y = DataUtils.round(Y, 2);</div><div class="line">LFPoint p = new LFPoint(X, Y, Point.bulge);</div><div class="line">return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>重点就是 重绘的时候每个点都要不断的进行转换,也就是在onDraw中不断的随手指的移动和缩放进行转换...看到了吗 下面有调用到获取屏幕的静态方法.就是它,不断的在获取,获取......导致了占用大量的资源 貌似也是每个144.我们继续...找</code></pre><p>到这里,我们的程序的卡顿情况,被我们清理的差不多了,终于不会卡了,瞬间感觉整个人都飘了,原来自己给自己挖了那么多的坑,小弟真实惭愧,网上的代码段固然方便,但是不能一味的直接拿来用,其中很多不知道的东西,你往往忽略了的地方就是问题存在的地方,当你无计可施的时候,还需要坚持 一步步探索,找寻答案.<br>顺便再啰嗦一句,onDraw中不可避免的是创建大量的path对象,这里根据网上搜寻的结果,总结了下还是用对象池比较好,但是网上有两个版本,一个是可以任何对象的,一个是只有自定义的类对象才可以,系统Path对象好像不行,所以简单的做了一下改动,<br>对,就是自定义path, 我啥都没改 仅仅是extend了一下,然后套用了下面的对象池的初始化方法,类似Handler的获取Message的时候的方式一样,不知道对不对,贴出代码,参考一下,反正我试过,可用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MyPath extends Path &#123;</div><div class="line"></div><div class="line">private static final SynchronizedPool&lt;MyPath&gt; sPool = new SynchronizedPool&lt;MyPath&gt;(10);</div><div class="line"></div><div class="line">public static MyPath obtain() &#123;</div><div class="line">MyPath instance = sPool.acquire();</div><div class="line">return (instance != null) ? instance : new MyPath();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void recycle() &#123;</div><div class="line">sPool.release(this);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好了,以上的寻找卡顿元凶之路,终于告一段落,还有很多地方需要优化的,后面再继续奉上,感谢看完的小伙伴,忍不住发一篇,希望能帮到你,后面我会继续更新出绘图相关的操作,比如画布的,比如view的,还有缩放,平移的实现,这些你是百谷不到的,那些基础的东西我看过很多,真的是千篇一律的.针对的平移缩放都是图片的操作而不是坐标点.<br>下次再见~有高见欢迎点评,虚心接受.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人新手一枚,第一次写博客,写的不好请勿喷,困扰小弟很久的问题,今天终于解决,这里奉上,供小伙伴借鉴,后面我会奉上从基础手指绘图到平移缩放所有的实现过程以及走过的坑,言归正传,下面开始列出我寻找卡顿元凶之路.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;采用双重画布的方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用GitHub+Hexo搭建个人博客</title>
    <link href="http://yoursite.com/2017/10/20/%E5%AD%A6%E4%B9%A0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/10/20/学习搭建个人博客/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-10-20T10:38:21.830Z</updated>
    
    <content type="html"><![CDATA[<p>第一个MarkDown文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一个MarkDown文章&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
